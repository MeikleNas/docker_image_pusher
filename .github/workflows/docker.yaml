name: Docker

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 21,9 * * *'  # 北京时间 5:00 和 17:00 执行

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  KEEP_LATEST_RUNS: 5  # 保留最近5条runs，可自行调整

jobs:
  build:
    name: Pull and Push Images
    runs-on: ubuntu-latest
    steps:
      # ===================== 第一步：紧急清理系统盘（核心！必须最靠前）=====================
      - name: EMERGENCY - Free up root disk space FIRST
        run: |
          echo "=== 紧急清理系统盘（/ 分区）==="
          # 1. 清理APT缓存和无用包（释放1-5GB）
          sudo apt autoremove -y --purge
          sudo apt clean
          sudo rm -rf /var/lib/apt/lists/*
          
          # 2. 删除超大体积预安装工具（释放20-50GB）
          sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/share/boost
          sudo rm -rf /usr/lib/jvm /usr/share/swift /opt/hostedtoolcache/CodeQL
          sudo rm -rf /opt/hostedtoolcache/Python /opt/hostedtoolcache/Node.js /opt/hostedtoolcache/go
          sudo rm -rf /usr/local/lib/android /opt/android /usr/local/android-sdk
          
          # 3. 清理Runner日志目录（直接解决日志写入失败问题）
          sudo rm -rf /home/runner/actions-runner/cached/_diag/*
          
          # 4. 清理临时文件
          sudo rm -rf /tmp/* /var/tmp/*
          
          # 5. 查看清理后系统盘状态（确认空间释放）
          echo "=== 系统盘清理后状态 ==="
          df -h /
          echo "=============================================================================="

      # ===================== 第二步：最大化构建空间 =====================
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 512    # 仅保留512MB根目录空间，释放更多可用空间
          swap-size-mb: 512
          remove-dotnet: 'true'
          remove-haskell: 'true'
          remove-android: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'
          build-mount-path: '/var/lib/docker/'

      # ===================== 第三步：重启Docker+检查空间 =====================
      - name: Restart Docker and check space
        run: |
          sudo service docker restart
          echo "=== 最终磁盘状态 ==="
          df -hT
          echo "=============================================================================="

      # ===================== 第四步：核心业务逻辑（拉取+推送镜像）=====================
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Docker Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push image to Aliyun
        run: |
          # 登录阿里云镜像仓库
          docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
          
          # 数据预处理：检测重名镜像
          declare -A duplicate_images
          declare -A temp_map
          while IFS= read -r line || [ -n "$line" ]; do
              # 忽略空行和注释
              [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
              
              # 提取镜像核心信息
              image=$(echo "$line" | awk '{print $NF}' | sed 's/@.*//')
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              name_space="${name_space}_"
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # 检测重名镜像（不同命名空间）
              if [[ -n "${temp_map[$image_name]}" ]]; then
                  if [[ "${temp_map[$image_name]}" != "$name_space" ]]; then
                      duplicate_images[$image_name]="true"
                  fi
              else
                  temp_map[$image_name]="$name_space"
              fi
          done < images.txt
          
          # 拉取、打标签、推送镜像
          while IFS= read -r line || [ -n "$line" ]; do
              # 忽略空行和注释
              [[ -z "$line" || "$line" =~ ^\s*# ]] && continue
              
              echo "=== 处理镜像：$line ==="
              # 拉取镜像
              docker pull "$line"
              
              # 提取架构信息（如有）
              platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
              platform_prefix=${platform:+${platform//\//_}_}
              
              # 提取镜像信息并构建新标签
              image=$(echo "$line" | awk '{print $NF}' | sed 's/@.*//')
              image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
              name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
              image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
              
              # 重名镜像添加命名空间前缀
              name_space_prefix=""
              if [[ -n "${duplicate_images[$image_name]}" && -n "$name_space" ]]; then
                  name_space_prefix="${name_space}_"
              fi
              
              # 构建新镜像名称
              new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/${platform_prefix}${name_space_prefix}${image_name_tag}"
              
              # 打标签并推送
              docker tag "$image" "$new_image"
              docker push "$new_image"
              
              # 即时清理镜像（释放Docker分区空间）
              echo "=== 清理当前镜像 ==="
              docker rmi -f "$image" "$new_image" || true
              docker system prune -f --volumes
              df -hT /var/lib/docker/
              echo "=============================================================================="
          done < images.txt

      # ===================== 第五步：最终清理+自动删除旧runs =====================
      - name: Final cleanup and auto delete old workflow runs
        if: always()  # 无论成功/失败都执行
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{ github.token }}  # 自动获取权限，无需手动配置
        run: |
          # 最终清理Docker资源
          echo "=== 最终清理Docker资源 ==="
          docker system prune -a -f --volumes
          sudo rm -rf /tmp/*
          
          # 自动删除旧的workflow runs
          echo "=== 自动清理旧workflow runs（保留最近$KEEP_LATEST_RUNS条）==="
          # 安装jq工具（解析JSON）
          sudo apt update && sudo apt install -y jq
          
          # 获取当前Docker workflow的ID
          WORKFLOW_ID=$(gh api "/repos/$GITHUB_REPOSITORY/actions/workflows" | jq -r '.workflows[] | select(.name=="Docker") | .id')
          if [[ -z "$WORKFLOW_ID" ]]; then
              echo "未找到Docker workflow，跳过清理"
              exit 0
          fi
          
          # 获取需要删除的旧runs ID（排除最近KEEP_LATEST_RUNS条）
          RUNS_TO_DELETE=$(gh api --paginate "/repos/$GITHUB_REPOSITORY/actions/workflows/$WORKFLOW_ID/runs?status=completed&per_page=100" \
            | jq -r --arg keep "$KEEP_LATEST_RUNS" '[.workflow_runs[] | .id] | .[$keep | tonumber:][]')
          
          # 批量删除旧runs
          if [[ -n "$RUNS_TO_DELETE" ]]; then
              echo "需要删除的runs ID：$RUNS_TO_DELETE"
              for RUN_ID in $RUNS_TO_DELETE; do
                  echo "删除run ID: $RUN_ID"
                  gh api "repos/$GITHUB_REPOSITORY/actions/runs/$RUN_ID" -X DELETE
                  sleep 1  # 避免API速率限制
              done
              echo "=== 旧runs清理完成 ==="
          else
              echo "=== 无需要删除的旧runs ==="
          fi
          
          # 最终磁盘状态
          df -hT
